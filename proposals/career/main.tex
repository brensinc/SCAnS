\documentclass[10pt]{dod-blank}

%% Language and font encodings
\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}

%% Sets page size and margins
%%\usepackage[a4paper,top=3cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}
%\usepackage[top=1in, bottom=1in, left=1in, right=1in]{geometry}

%% Useful packages
\usepackage{amsmath}
\usepackage{graphicx}
  \graphicspath{{.}{./image/}}
  \DeclareGraphicsExtensions{.png,.jpg} 
\usepackage[colorinlistoftodos]{todonotes}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}
\usepackage{tabularx}
\usepackage{multirow}
\usepackage{tabulary}
\usepackage{float}
\usepackage{wrapfig}
\usepackage[export]{adjustbox}
\usepackage{comment}
\usepackage{tabularx}
\usepackage{multirow}
\usepackage{tabulary}
\usepackage{enumitem}

\usepackage{listings}
\usepackage{color}
\usepackage{array}
\usepackage{subcaption}
\usepackage{xcolor}

\renewcommand{\textfraction}{0}
\renewcommand{\topfraction}{1.0}
\renewcommand{\bottomfraction}{1.0}

\usepackage{longtable}
%% macros
\newif\iffinal
\finaltrue
\iffinal
  
    \newcommand\baareq[1]{}
    \newcommand\baades[1]{}
 
 
\else
    \definecolor{darkgreen}{rgb}{0,0.4,0}
    \definecolor{darkcyan}{rgb}{0,0.4,0.4}
    \definecolor{darkblue}{rgb}{0,0,0.5}
    
    \newcommand\baareq[1]{{\color{darkcyan}[\textbf{Requirement:} #1]}}
    \newcommand\baades[1]{{\color{darkcyan}[\textbf{Description:} #1]}}
 
\fi




\def\naive{na\"{\i}ve}



\lstset{ 
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\footnotesize\ttfamily,            % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  % deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=single,	                   % adds a frame around the code
  keepspaces=false,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue}\bfseries\underbar,       % keyword style
  language=Prolog,                 % the language of the code
  % morekeywords={if,and},        % if you want to add more keywords to the set
  numbers=none,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=2,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,	                   % sets default tabsize to 2 spaces
  title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}

% apply trick for additional keywords for our AC DSL
\lstset{
	emph={for, if, and, or},
    emphstyle={\color{blue}\bfseries\underbar}
}

% \title{High-Assurance Learning-Enabled Cyber-Physical System Design}
% \author{Pierluigi Nuzzo, EE Department, University of Southern California, Los Angeles, CA}

\begin{document}

% \maketitle
\section*{High-Assurance Design of Learning-Enabled Cyber-Physical Systems} 

\subsubsection*{Pierluigi Nuzzo, Department of Electrical Engineering, University of Southern California, \\ Los Angeles, CA}

\paragraph*{Overview.}

% what the research project is, 
% sets the research in context, 
%
Over the last decade, machine learning (ML) algorithms have achieved impressive results in solving large-scale perception problems for decision-making under uncertainty in autonomous cyber-physical systems (CPSs) (see, e.g.,~\cite{Blum97,Jia14,Michalski13}).  While autonomous systems heavily depend on situational awareness and ML components, their safety-critical nature raises concerns on the overall system safety and trustworthiness. In fact, 
% recent efforts toward the verification of ML programs~\cite{Szegedy2013} show how 
even well-trained neural networks can be sensitive to small perturbations, e.g., small modifications can lead the network to misclassify the altered input with large confidence~\cite{Szegedy2013}. In systems with complex interactions, a misclassification error in one component may eventually compromise the entire functionality and cause accidents and fatalities, such as the ones recently reported for self-driving cars.
% 
While exhaustive testing  is a prohibitive task~\cite{Kalra16}, the complexity, heterogeneity, and highly dynamic nature of learning-enabled cyber-physical systems (LE-CPSs)
make it challenging to even leverage existing model-based development techniques to effectively assess  their correctness, dependability, and compliance with regulations.  New rigorous design and analysis technologies are sorely needed to guarantee safety properties for these systems.   
% LE-CPSs require significant levels of adaptiveness and resilience to unpredictable scenarios:
% for example, in response to changes in the environment or in the operating conditions of the learning components with respect to their training conditions. 
Moreover, assumptions made at design time may break at run time, and correctness claims must often be  based on evidence that can only be provided during system operation.
%
\emph{In this project, we pursue a holistic approach for rigorous design of LE-CPSs spanning design methodology, analysis and synthesis algorithms, and certified system architectures.  
Rather than focusing on ML components in isolation, we seek to systematically specify and analyze the behaviors of ML components within the context of a CPS and propose a methodology that can contextually generate safe architectures and their proofs of correctness.} We will develop a modeling framework, methods, and tools that can support the design process from system-level requirement capture, formalization, and analysis, to the generation, testing, and continual monitoring of software and hardware artifacts, including ML components, in feedback loop with physical processes.
% coordinated research effort toward the development of (i) a novel compositional contract-based framework for LE-CPSs, (ii) theories and tools for cross-layer, resilient, LE-CPS design, including modeling and construction of high-assurance learning systems, and (iii) an all-encompassing methodology bridging design-time and dynamic assurance.

\paragraph{Intellectual Merit.}
% identifies challenges 
% approaches to be taken, 
% discusses how success will be evaluated 

We will follow a contract-based approach~\cite{Nuzzo15b,Sangiovanni-Vincentelli2012a}, which has shown to be promising for complex CPS design, since it facilitates the realization of modular architectures that are \emph{correct by construction}, and leverages compositional reasoning to enhance the \emph{scalability} of design and verification. A contract can be intuitively seen as a pair $(A,G)$ of properties, where $A$ specifies the assumptions that a component makes on the external environment and $G$ the guarantees it provides under these assumptions. Contract-based design has emerged as a unifying, formal, compositional paradigm that can enable modular and hierarchical verification of system properties, 
% of a system, whose satisfaction can be proven based on the satisfaction of local properties of the components~\cite{Cimatti15b}. Contracts support 
rigorous stepwise refinement, 
% where hierarchical specifications can be used to reason about component decompositions, even if the component implementations are not yet available~\cite{Cimatti15b,Nuzzo14,Iannopollo14}. 
and component reuse. 
% as any components satisfying a contract directly inherit its guarantees~\cite{Iannopollo14}. 
% Contract constructs, carrying claims as well as evidence, context and assumptions, thus become critical reasoning elements in our dynamic assurance case.
% 
Contracts have shown to be effective for specifying and reasoning about systems, especially when component models belong to the same level of abstraction (e.g., algorithm, software, architecture) or adopt the same formalism. 
However, there is no universal modeling formalism that can capture every aspect of complex, heterogeneous LE-CPSs, and guarantee, at the same time, tractable analysis. Designers usually ``decompose'' a complex system into semantically different models, by adopting the most convenient formalisms to represent different design viewpoints (e.g., system functionality, timing, safety, and reliability) at different abstraction levels. They then leverage the most suitable tools to analyze and synthesize these models separately. 
For example, the control law for a vehicle is typically derived and initially evaluated using control-oriented models, e.g., discrete-time linear models, in which details of the implementation and the physical dynamics are simplified or neglected. These details are usually modeled and evaluated using other formalisms and tools, e.g., by simulation of continuous-time differential algebraic equations. Each model represents some aspects of system design and occludes others, by making simplifying assumptions that are often undocumented or informally captured at best. A set of challenges then remain for model-based design flows when models are to be formulated and manipulated along the design flow, across different abstraction levels, and between design time and operation time. ML components further exacerbate these difficulties due to the lack of practical and reliable abstractions that can encompass the heterogeneity of ML algorithms and architectures (e.g., data-driven classifiers for perception and situational awareness, reinforcement learning for developing control policies, and algorithms for learning system dynamics) and the different nature of their performance and safety properties. \emph{Our vision for LE-CPS design is that compositional abstractions should bridge heterogeneous formalisms and heterogeneous decomposition architectures, to make system analysis and synthesis tractable, to consistently combine different verification and synthesis methods at design time, and to provide seamless support for dynamic assurance at run time.}  We will pursue this vision via the following multi-pronged approach: 

(1) \underline{\textit{Hierarchical Heterogeneous Design Methodology.}} We formalize the design as a layered process. 
At each abstraction layer, a representation of the design is built out of a library
(collection) of components according to composition rules. 
% The bottom-up phase of design flow consists in building the component library. In the top-down phase, 
The high-level requirements are formalized and a \emph{design refinement} step called \emph{mapping} is performed, where the requirements are mapped into the implementation library components. 
All the components and their aggregations will be specified by \emph{contracts}. The contracts will be  used to construct mathematical evidence that a design is correct and consistent with its physical implementation under certain assumptions on the external environment. We will develop libraries, algorithms, and tools for capturing requirements of LE-CPSs, for translating them into contracts, for analyzing and validating them using contract operations and relations, and for synthesizing design and verification artifacts from contracts.  
% Hierarchical architecture exploration and mapping will be carried out by combining a set of formal verification, synthesis, and simulation-based testing techniques. 

(2) \underline{\textit{Vertical Contracts.}} While contracts are traditionally used to reason about ``horizontal'' compositions of ``homogeneous'' elements at the same abstraction level, we will develop a theory of \emph{vertical contracts} as a foundation to fully support  multi-layer design with heterogeneous models. 
% by combining effective algorithms and tools at different abstraction layers~\cite{Nuzzo15b}. 
Intuitively, if vertical contracts are satisfied, the mapping mechanism defined above can be used to produce design refinements that are correct. In model-based verification, abstractions between heterogeneous models were established in the past for specific pairs of formalisms, such as hybrid abstractions of nonlinear systems~\cite{Henzinger98,Dang10}, linear hybrid automata abstractions of linear
hybrid systems~\cite{Frehse2008}, discrete abstractions of hybrid systems~\cite{Alur00,Alur2006,Chutinan01}. Our work aims to generalize these notions toward a formulation that is compositional, scalable, and systematically applies to virtually any pair of formalisms. 
% A key criterion on mappings is that they preserve safety properties.
% that is, if safety property $p$ is established in model $M_1$ and $M_1$ is mapped
% to model $M_2$, then the safety property $p$ holds in $M_2$, without the need to
% reprove it. 
% Refinement mappings between behavioral models are commonly formalized as simulation relations~\cite{Milner89}.  
% The details depend on the
% particular kind of behaviors that a model exhibits, but the essential
% proof obligation is to show that each concrete behavior corresponds in
% a systematic way to some abstract behavior via a simulation relation
% between concrete and abstract states.  Since the behaviors of the
% abstract model are a superset of those required of the implementation,
% then by design the concrete behaviors also satisfy requirements. 
We will use concepts from \emph{abstract interpretation} as a means to build \emph{conservative approximations} for verifying or enforcing safety properties in behavioral models. Abstract interpretation works by creating an 
abstraction of the model in which it is more efficient (i)
to infer state invariants and behavioral properties, and (ii) to prove properties on the given model~\cite{Cousot77,Passerone2007}. 
Abstract interpretation will be combined with \emph{model order reduction} techniques to provide a foundation for the  verification of contract refinement as well as the generation of efficient runtime monitors.

(3) \underline{\textit{Abstraction of Learning Components.}} Learning components are usually required to achieve high accuracy, integrate data from several sensors, and run efficiently on embedded processors. Learning techniques are heterogeneous, depending on their  architectural structure (hierarchical, decentralized, or centralized), varying environment conditions, and the tight accuracy, latency, and energy constraints.  
% However, such variations in the learning systems must not compromise on key safety and performance objectives. 
We will develop theories and tools for abstraction and analysis of heterogeneous learning systems that can be used to inform architectural decisions and trade performance with safety, robustness, and computation time.

(4) \underline{\textit{Scalable Computational Tools for Verification and Synthesis.}} The robust control of continuous dynamical systems often involves the reduction of the control problem to a convex optimization problem. On the other hand, the design and verification of discrete systems involves the use of Boolean satisfiability (SAT)~\cite{Malik09} solving. We will build upon a nascent framework that combines both SAT solving and convex optimization, termed as Satisfiability Modulo Convex programming (SMC)~\cite{Shoukry2017}, to develop efficient computational tools to jointly reason about discrete and continuous dynamics,  and support constraint solving problems that arise in the verification and synthesis of LE components and systems.  
%\noindent\textbf{Property Enforcement and Formal Verification by Abstract Interpretation.} 
%A system $S$ satisfies a specification $P$ if all behaviors of $S$ are
%included in $P$. 
%% Given a system description $F:S\mapsto 2^S$ that maps
%% states to sets of states, the least fixed point of the predicate
%% transformer ${\cal F}(X) = \Theta \vee X \vee F(X)$ starting from
%%  $false$ describes exactly the set of reachable states. Thus, for a
%% state property $P$ proving satisfaction reduces to proving {\it lfp}$({\cal
%%   F}({\it false})) \subseteq P$. 
%Proving satisfaction requires the computation of the set of reachable states of $S$, whose termination may be undecidable, or not even guaranteed, in practice. 
%% In practice this approach suffers from two
%% problems: (1) the sequence ${\cal F}({\it false})$, ${\cal F}^2({\it false})$,
%% $\ldots$, may not converge in a finite number of steps, and (2) even
%% if it does converge, we may not be able to detect convergence, because the
%% inclusion ${\cal F}^{n+1}({\it false}) \subseteq {\cal F}^n({\it false})$ may be
%% undecidable.
%Abstract interpretation~\cite{Cousot77}, a mathematical theory of approximation
%% developed by Cousot and Cousot, 
%provides a powerful 
%solution to these problem, by performing the computation in an
%abstract domain in which the detection of convergence is decidable, and guaranteeing that the results can be translated back to the concrete domain. 
%% 
%% It performs the forward propagation in an
%% abstract domain in which the detection of convergence is decidable,
%% resulting in a fixed point that, when translated back to the concrete
%% domain, is guaranteed to be a fixed point of the concrete predicate
%% transformer. The application of abstract interpretation requires the
%% definition of an abstract domain $\Sigma_A$ equipped with a partial
%% order $\leq_A$, an abstraction function $\alpha: 2^S \mapsto \Sigma_A$
%% that maps sets of concrete states $S \subseteq \Sigma$, into elements
%% of the abstract domain, and a concretization function $\gamma:
%% \Sigma_A \mapsto 2^S$, 
%% such that $\alpha,\gamma$ form a Galois
%% connection, that is, they must satisfy $\alpha(S) \leq_A a$ iff $S
%% \subseteq \gamma(a)$ for all $S \subseteq \Sigma$ and $a \in \Sigma_A$.
%%
%The theory of abstract interpretation is well understood and many
%abstract domains of various levels of expressiveness have been
%proposed in the literature over the past decades~\cite{DBLP:journals/acta/Karr76,DBLP:conf/popl/CousotH78,DBLP:conf/popl/SankaranarayananSM04,DBLP:conf/vmcai/SankaranarayananSM05,DBLP:conf/vmcai/SankaranarayananCSM06}. Its practical
%application, however, has proven difficult. 

%  Kestrel Technology is one of only a few organizations that have an abstract interpretation
% engine, called CodeHawk, that scales to real-world systems. In particular, CodeHawk has been applied to sound memory safety analysis of C programs of up to 400,000
% lines of code and the analysis of various other (state) properties of
% Java programs of more than a million lines of code.

%For  behavioral requirements on the CPS, our abstract interpretation technology provides a foundation for the verification of contract refinement relationships described above as well as the generation of efficient, localized monitoring code.
%
%We propose to develop (1) new front ends for our abstract
%interpretation engine for the modeling languages created under this
%project, that allow proving properties over models and refinements
%between different levels of abstractions; (2) new abstract domains
%that can express nonlinear behaviors;
%% (3) a new methodology for proving temporal properties over models and
%% programs by creating and discharging proof obligations that ensure
%% system transitions stay within the behavior allowed by an automaton;
%% (4) a new methodology for enforcing temporal safety properties over
%% models and programs by refining contracts on components to eliminate
%% unsafe behaviors;
%% (5) techniques to provide bounds on performance constraints such as
%% maximum CPU time and memory usage; and 
%(6) transformations to generate runtime monitors based on local residual properties that cannot be proved or enforced.

% Conditions to monitor can come from critical assumptions on the CPS design, modeled as automata, and well-known algorithms can be used for synthesizing efficient monitors, e.g., \cite{Havelund04,Rosu08}.

% \noindent\textbf{Simulation-Based Testing and System Testing.}  
During the first phase of the project, we will consider scenarios from autonomous driving in unknown urban environments to prototype and evaluate our methodology and tools. We can then leverage state-of-the-art traffic simulators (e.g., PTV VISSIM) to 
% prototype and validate our design flow and 
test the real-time performance and safety of our solutions. 
% VISSIM allows simulating traffic patterns based on the dynamics and driver actions of each vehicle as well as their interaction with each other and the road. 
% An API allows the user to replace the default driver model  with a customized one as well as implement and simulate the dynamics of learning components in the loop. Further, it allows generating unpredictable scenarios 
% (e.g., incidents,  violations of traffic rules) and generate and 
% and collect data to train ML components. 
As we target industrial-strength platforms, we will also partner with the new Center of Advanced Manufacturing and the Robotics and Autonomous Systems Center at USC, and with industry (e.g., Toyota, United Technologies Inc.) to identify appropriate scenarios in robotics, autonomous vehicles, and industrial automation, and corresponding testbeds to validate the proposed modeling infrastructure, methodology, and algorithms.  
% that provides a level of fidelity for simulation-based testing that can be relied upon for critical applications and leverages physical model analysis tools to facilitate the identification of problematic behavior spaces. 

\paragraph{Broader Impact.} In addition to disseminating the results through publications and workshops, we will collaborate with industry partners on transitioning the research findings into practice. Moreover, the theories, software, and hardware prototypes realized during this project will be leveraged for the development of an interdisciplinary education program targeting K-12, undergraduate, and graduate students, and focused on principled design and deployment of autonomous LE-CPSs as well as the impact of learning-enabled technologies on our life and safety. This effort will also include the development of a new course on autonomous CPS design together with the course textbook. 
% describes the integration of research and education

{\scriptsize
\bibliographystyle{acm} 
\bibliography{TA3/ta3,TA2/ta2,TA1/ta1}
}

\end{document}